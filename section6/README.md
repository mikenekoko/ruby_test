# 6章 正規表現を理解する
* 正規表現を書くやつ、結構perlと同じっぽい
* `文字列など =~ 正規表現`

```ruby
# Regexp クラスになるよ
regex = /\d{3}-\d{4}/
p regex.class
```

* 真偽値で返ってくるのでif文の条件として使えるよ

```ruby
# マッチした場合は文字列の開始位置が返る。つまり、真である
p '123-4567' =~ regex
-> 0

# マッチしない場合はnil。つまり、偽である
p 'hello' =~ regex
-> nil

# 順番逆でも結果は同じ。
p regex =~ '123-4567'
```

* `!~` を使うとマッチの結果を true / false で返すことができる

```ruby
p '123-4567' !~ regex
-> true
p 'hello' !~ regex
-> false
```

## キャプチャ
* `()` で囲う事で、マッチした文字列を取得できる
* `match` マッチすることで、MatchDataオブジェクトが返ってくる。マッチしないとnilが返ってくる

```ruby
# キャプチャ
text = '私の誕生日は1960年10月1日です。'
m = /(\d+)年(\d+)月(\d+)日/.match(text)
# MatchDataのオブジェクト
p m
-> #<MatchData "1960年10月1日" 1:"1960" 2:"10" 3:"1">

# マッチした部分全体
p m[0]
-> "1960年10月1日"

# 残りマッチした順番
p m[1]
p m[2]
p m[3]
"1960"
"10"
"1"

# 2番目から2個
p m[2, 2]
-> ["10", "1"]

# 最後
p m[-1]
-> "1"

# Rangeを使って範囲指定
p m[1..3]
-> ["1960", "10", "1"]

# 代入と同時にやる
text = '私の誕生日は1960年10月1日です。'
if m = /(\d+)年(\d+)月(\d+)日/.match(text)
  # マッチした場合の処理、mをそのまま使える
else
  # マッチしない処理
end

# Stringクラスにもmatchは定義されているから以下のように呼べる
/(\d+)年(\d+)月(\d+)日/.match(text)
text.match(/(\d+)年(\d+)月(\d+)日/)
```

* `(?<name>)` というメタ文字を使って名前を付けることができる
* 何番目にマッチしたもの～と覚えなくていいため可読性もよくバグも置きづらい
* シンボルで付けられる

```ruby
m = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)
-> #<MatchData "1960年10月1日" year:"1960" month:"10" day:"1">

# 取得
m[:year]
m[:month]
m[:day]

# 一応文字列でも取れる
m['year']

# 今まで通り連番でも取れる
m[1]
```

* 名前付きキャプチャのもう一つの能力に、左辺に正規表現リテラルを持ってきた場合にキャプチャの名前がそのままローカル変数に割り当てられる
* これめっちゃ便利

```ruby
text = '私の誕生日は1960年10月1日です。'
if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/ =~ text
  p "#{year} : #{month} : #{day}"
end
-> "1960 : 10 : 1"

# match使ったりしてもダメ
if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)
# -> sample.rb:51:in `<main>': undefined local variable or method `year' for main:Object (NameError)

# 逆にしたらだめ
if text =~ /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/

# 変数にいったん入れたりしてもダメ
regexp = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/
if regexp =~ text
```

* 正規表現を直で書かないとだめらしい。定数化とかできないの気になるな。なんでダメなんだろう。

# 正規表現と組み合わせるStringメソッド
## scan
* 正規表現にマッチした部分を配列にして返す

```ruby
# scan
p '123 456 789'.scan(/\d+/)
-> ["123", "456", "789"]

# 正規表現に()があると、キャプチャされた部分が配列の配列になって帰ってくる
p '1977年7月17日 2016年12月31日'.scan(/(\d+)年(\d+)月(\d+)日/)
-> [["1977", "7", "17"], ["2016", "12", "31"]]
```

* `(?:)` グループ化はしたいが、キャプチャはせず文字列全体を取得したい場合に使う

```ruby
p '1977年7月17日 2016年12月31日'.scan(/(?:\d+)年(?:\d+)月(?:\d+)日/)
-> ["1977年7月17日", "2016年12月31日"]

# 正直これでもいい
p '1977年7月17日 2016年12月31日'.scan(/\d+年\d+月\d+日/)
```

## [], slice, slice!
* `[]` に正規表現を渡すと、文字列から正規表現にマッチした部分を返す

```ruby

```

* キャプチャを使うと第二引数で何番目のキャプチャを取得するか指定できる

```ruby
text = '私の誕生日は1977年7月17日です'
p text[/(\d+)年(\d+)月(\d+)日/, 3]
-> "17"

# なんも指定しないとぜんぶ返ってくる
p text[/(\d+)年(\d+)月(\d+)日/]
-> "1977年7月17日"

# 名前付きキャプチャなら名前で指定できる
p text[/(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/, :year]
```

* `slice()` はエイリアスメソッドなので同じ
* `slice!()` はマッチした部分が文字列から破壊的に取り除かれる。実質文字列削除

```ruby
p text.slice(/(\d+)年(\d+)月(\d+)日/)

# 文字列を消す。返り血は消した値になる
p text.slice!(/(\d+)年(\d+)月(\d+)日/)
-> "1977年7月17日"
p text
-> "私の誕生日はです"
```

## split
* マッチした文字列を区切り文字にして文字列を分解し配列にして返す

```ruby
text = "123,456-7890"

# カンマで区切る
p text.split(',')
-> ["123", "456-7890"]

# カンマまたはハイフンで区切る
p text.split(/,|-/)
-> ["123", "456", "7890"]
```

## gsub, gsub!
* 第一引数の正規表現にマッチしたものを第二引数に置換
* `gsub` は配列を返し、 `gsub!` は破壊変更する

```ruby
p text.gsub(',', ':')
-> "123:456-7890"
p text.gsub(/,|-/, ':')
-> "123:456:7890"
```

* キャプチャを使うと、第二引数で `\1`, `\2` で参照できる
* 名前付き引数ならば、 `\k<name>` で参照できる

```ruby
text = '私の誕生日は1977年7月17日です'

p text.gsub(/(\d+)年(\d+)月(\d+)日/, '\1-\2-\3')
p text.gsub(
  /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/,
  '\k<year>-\k<month>-\k<day>'
)
```

* 第二引数にハッシュを渡して変換ルールを指定することが可能

```ruby
text = "123,456-7890"
hash = { ',' => ':', '-' => '/'}
p text.gsub(/,|-/, hash)
-> "123:456/7890"
```

* ブロックの戻り値で置き換える文字列を指定することも可能
```ruby
p text.gsub(/,|-/) { |matched| matched == ',' ? ':' : '/' }
-> "123:456/7890"
```

# 正規表現オブジェクトについてもっと詳しく
## 色々な新規作成方法
```ruby
# Regexp.new を使う
Regexp.new('\d{3}-\d{4}')

# %r を使う
%r!http://example\.com!
%r{http://example\.com}
```

* `/ /` や `%r` の中で `#{}` を使うと変数展開できる

```ruby
pattern = '\d{3}-\d{4}'
'123-4567' =~ /#{pattern}/
```

## case で正規表現を使える
* そのまま when句 に書けばOK

```ruby
case text
when /正規表現/
  ~~~~
end
```

## 正規表現のいろんなオプション
* `i` : 大文字小文字を区別しない
* `m` : 任意の文字を表す ドット が改行文字にもマッチする
* `x` : 半角文字が無視され、 #を使ってのコメントアウトが正規表現中にかける

## 組み込み変数でマッチの結果を取得する
* `$` で始まる、様々な組み込み変数がある。
* =~ や match を使うといくつかの組み込み変数にマッチした結果が代入される
* perlと同じ！
* `$~` : MatchDataオブジェクトを取得する
* `$&` : マッチした部分全体を取得する
* `$1, $2...` : マッチしたキャプチャを取得する
* `$+` : 最後のキャプチャ文字列を取得する
* matchメソッドを使い、明示的にMatchDataオブジェクトを受け取る方が可読性や保守性の面で優れているので筆者的には推奨してないとのこと

## Regexp.last_match
* 最後に `=~` などにマッチしたものを取得する
* 暗黙的に入るものなので、ちょっと扱いづらい。

## match?
* 2.4 から追加された比較的新しいメソッド。
* マッチするかどうかの true/false をシンプルに返すのみ。
* $ や last_match の組み込み変数を書き換えないため、動作が高速