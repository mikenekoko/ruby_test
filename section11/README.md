# 11章 デバッグ技法を身に着ける
* バックトレースの読み方は流石にわかるので割愛

## 例外クラス種類
### NameError
* 未定義の変数定数、privateメソッドの呼び出しで発生する
* 大体、定義か継承忘れかタイポ

### NoMethodError
* 存在しないメソッドを呼び出そうとしたときに発生
* これもタイポだったり、レシーバが想像していない型（nilとか）で返ってきているパターン

### TypeError
* 期待しない型がメソッドの引数に渡されたときに発生
* 10 + '1' とかね

### ArgumentError
* 引数の数が違ったり、期待する値でないときにでる

### ZeroDivisionError
* 整数を0で除算しようとしたときに発生
* 計算式しくったらでるやつ

### SystemStackError
* システムスタックがあふれたときに発生
* つまり、メソッドを再帰呼び出しで無限ループしたときとかになる

### LoadError
* requireやloadの実行ミス
* パス指定ミスや、gemに入っていないなど

### SyntaxError
* 構文エラー。いつもの。

# 色々なデバッグ方法
## tap
* tapメソッドは、ブロックチェーンのデバッグに役立つ
* レシーバをそのまま返り値にするので、tapを挟む前と同じ振る舞いをするよ！

```ruby
# 結果は問題ないけど途中でちゃんと動いてるか不安だな
'#043c78'.scan(/\w\w/).map(&:hex)

# tapを挟むことで途中結果のデバッグができた！
'#043c78'.scan(/\w\w/).tap { |rgb| p rgb }.map(&:hex)
-> ["04", "3c", "78"]
```

## デバッガ（Byebug）を使う
* gemのライブラリの一つで、対話型にデバッグできる
* debugライブラリというのもデフォで入ってるが、現場ではByebugの方が使われている

|コマンド|説明|
|:--:|:--:|
|eval + (式)|変数の値やメソッドの戻り値を表示|
|step/s|実行を1ステップ進める。<br>メソッドがあればそのメソッドの中に入って停止する|
|next/n|実行を1ステップ進める。<br>メソッドがあればメソッドの中に入らずに次のステップで停止する|
|finish/fin|現在実行中のメソッドを最後まで実行<br>呼び出し元に戻ってきたところで停止|
|continue/cont/c|処理を再開する<br>ブレークポイントが無ければ最後まで実行|
|リターンキー|直前に実行したコマンドを繰り返す|
|help|使用可能コマンドの説明をする|
|quit/q|Byebugを途中で終了する|

* これめっちゃ便利だわ

## ライブラリのコードを読む
* スクリプト言語なので、ライブラリも全部自分のローカルにあるはずなのでそれを読もう
* `source_location` メソッドで探すことができるよ
  * `~~~.method(:メソッド名).order_item`
* Rubyの標準メソッドはnilで返ってきちゃうよ。 upcase とか

## テストコードを書く
* 複雑なエラーにつまったら、一旦はテストコードを書いてしまうのも手。
* こうなってほしい　というテストコードを作って実行していけば毎回デバッグしていく必要が無くなる
* また、テストコードがそのまま出来上がるのも利点